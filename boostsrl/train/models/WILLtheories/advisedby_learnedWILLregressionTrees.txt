usePrologVariables: true.

% maxTreeDepthInNodes                 = 3
% maxTreeDepthInLiterals              = 12
% maxNumberOfLiteralsAtAnInteriorNode = 2
% maxFreeBridgersInBody               = 1
% maxNumberOfClauses                  = 8
% maxNodesToConsider                  = 10
% maxNodesToCreate                    = 10.000
% maxAcceptableNodeScoreToStop        = 0,003
% negPosRatio                         = 2,000
% testNegPosRatio                     = -1,000
% # of pos examples                   = 156
% # of neg examples                   = 0



%%%%%  WILL-Produced Tree #1 @ 20:41:17 12/15/20.  [Using 3.399.936 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( professor(B), student(A) )
%   then if ( tempadvisedby(C, A), tempadvisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return 0.7445125714631483;  // std dev = 2,977, 88,000 (wgt'ed) examples reached here.  /* #neg=10 #pos=78 */
%   else return -0.14185106490048768;  // std dev = 5,96e-08, 68,000 (wgt'ed) examples reached here.  /* #neg=68 */


% Clauses:

advisedby(A, B, 0) :- 
     professor(B), 
     student(A), 
     tempadvisedby(C, A), 
     tempadvisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, 0.7445125714631483) :- 
     professor(B), 
     student(A), 
     !. // Clause #2.

advisedby(A, B, -0.14185106490048768) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   professor(b),
   student(a),
   tempadvisedby(uniqueVar1, a),
   tempadvisedby(uniqueVar1, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, 0.7445125714631483) :-  /* #neg=10 #pos=78 */ 
   professor(b),
   student(a),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, -0.14185106490048768) :-  /* #neg=68 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   professor(b)
%   tempadvisedby(uniqueVar1, a)
%   tempadvisedby(uniqueVar1, b)
%   student(a)

%%%%%  WILL-Produced Tree #2 @ 20:41:17 12/15/20.  [Using 3.450.040 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( professor(B), student(A) )
%   then if ( advisedby(C, A), tempadvisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return 0.6281908794091159;  // std dev = 2,977, 88,000 (wgt'ed) examples reached here.  /* #neg=10 #pos=78 */
%   else return -0.1254446385283916;  // std dev = 0,000, 68,000 (wgt'ed) examples reached here.  /* #neg=68 */


% Clauses:

advisedby(A, B, 0) :- 
     professor(B), 
     student(A), 
     advisedby(C, A), 
     tempadvisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, 0.6281908794091159) :- 
     professor(B), 
     student(A), 
     !. // Clause #2.

advisedby(A, B, -0.1254446385283916) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   professor(b),
   student(a),
   advisedby(uniqueVar2, a),
   tempadvisedby(uniqueVar2, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, 0.6281908794091159) :-  /* #neg=10 #pos=78 */ 
   professor(b),
   student(a),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, -0.1254446385283916) :-  /* #neg=68 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   professor(b)
%   student(a)
%   advisedby(uniqueVar2, a)
%   tempadvisedby(uniqueVar2, b)

%%%%%  WILL-Produced Tree #3 @ 20:41:17 12/15/20.  [Using 3.515.984 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( student(B), professor(A) )
%   then if ( sameperson(C, A), advisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return -0.11231637819360638;  // std dev = 1,05e-08, 23,000 (wgt'ed) examples reached here.  /* #neg=23 */
%   else return 0.28726180730668105;  // std dev = 4,441, 133,000 (wgt'ed) examples reached here.  /* #neg=55 #pos=78 */


% Clauses:

advisedby(A, B, 0) :- 
     student(B), 
     professor(A), 
     sameperson(C, A), 
     advisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, -0.11231637819360638) :- 
     student(B), 
     professor(A), 
     !. // Clause #2.

advisedby(A, B, 0.28726180730668105) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   student(b),
   professor(a),
   sameperson(uniqueVar3, a),
   advisedby(uniqueVar3, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, -0.11231637819360638) :-  /* #neg=23 */ 
   student(b),
   professor(a),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, 0.28726180730668105) :-  /* #neg=55 #pos=78 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   advisedby(uniqueVar3, b)
%   sameperson(uniqueVar3, a)
%   professor(a)
%   student(b)

%%%%%  WILL-Produced Tree #4 @ 20:41:18 12/15/20.  [Using 3.556.624 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( professor(B), student(A) )
%   then if ( advisedby(C, A), sameperson(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return 0.42131522454653036;  // std dev = 2,977, 88,000 (wgt'ed) examples reached here.  /* #neg=10 #pos=78 */
%   else return -0.12985541570248574;  // std dev = 0,167, 68,000 (wgt'ed) examples reached here.  /* #neg=68 */


% Clauses:

advisedby(A, B, 0) :- 
     professor(B), 
     student(A), 
     advisedby(C, A), 
     sameperson(C, B), 
     !. // Clause #1.

advisedby(A, B, 0.42131522454653036) :- 
     professor(B), 
     student(A), 
     !. // Clause #2.

advisedby(A, B, -0.12985541570248574) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   professor(b),
   student(a),
   advisedby(uniqueVar4, a),
   sameperson(uniqueVar4, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, 0.42131522454653036) :-  /* #neg=10 #pos=78 */ 
   professor(b),
   student(a),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, -0.12985541570248574) :-  /* #neg=68 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   professor(b)
%   sameperson(uniqueVar4, b)
%   advisedby(uniqueVar4, a)
%   student(a)

%%%%%  WILL-Produced Tree #5 @ 20:41:18 12/15/20.  [Using 3.599.528 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( student(A), student(B) )
%   then if ( tempadvisedby(C, A), advisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return -0.12899328789695194;  // std dev = 0,000, 37,000 (wgt'ed) examples reached here.  /* #neg=37 */
%   else return 0.2079201615675733;  // std dev = 3,585, 119,000 (wgt'ed) examples reached here.  /* #neg=41 #pos=78 */


% Clauses:

advisedby(A, B, 0) :- 
     student(A), 
     student(B), 
     tempadvisedby(C, A), 
     advisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, -0.12899328789695194) :- 
     student(A), 
     student(B), 
     !. // Clause #2.

advisedby(A, B, 0.2079201615675733) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   student(a),
   student(b),
   tempadvisedby(uniqueVar5, a),
   advisedby(uniqueVar5, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, -0.12899328789695194) :-  /* #neg=37 */ 
   student(a),
   student(b),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, 0.2079201615675733) :-  /* #neg=41 #pos=78 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   tempadvisedby(uniqueVar5, a)
%   student(a)
%   advisedby(uniqueVar5, b)
%   student(b)

%%%%%  WILL-Produced Tree #6 @ 20:41:18 12/15/20.  [Using 3.641.504 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( student(A), professor(B) )
%   then if ( advisedby(C, A), tempadvisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return 0.2664455298682112;  // std dev = 2,977, 88,000 (wgt'ed) examples reached here.  /* #neg=10 #pos=78 */
%   else return -0.11766348224505459;  // std dev = 0,113, 68,000 (wgt'ed) examples reached here.  /* #neg=68 */


% Clauses:

advisedby(A, B, 0) :- 
     student(A), 
     professor(B), 
     advisedby(C, A), 
     tempadvisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, 0.2664455298682112) :- 
     student(A), 
     professor(B), 
     !. // Clause #2.

advisedby(A, B, -0.11766348224505459) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   student(a),
   professor(b),
   advisedby(uniqueVar6, a),
   tempadvisedby(uniqueVar6, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, 0.2664455298682112) :-  /* #neg=10 #pos=78 */ 
   student(a),
   professor(b),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, -0.11766348224505459) :-  /* #neg=68 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   professor(b)
%   tempadvisedby(uniqueVar6, b)
%   student(a)
%   advisedby(uniqueVar6, a)

%%%%%  WILL-Produced Tree #7 @ 20:41:18 12/15/20.  [Using 3.680.328 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( professor(B), student(A) )
%   then if ( advisedby(C, A), tempadvisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return 0.2059559107439094;  // std dev = 2,977, 88,000 (wgt'ed) examples reached here.  /* #neg=10 #pos=78 */
%   else return -0.10600575567921348;  // std dev = 0,103, 68,000 (wgt'ed) examples reached here.  /* #neg=68 */


% Clauses:

advisedby(A, B, 0) :- 
     professor(B), 
     student(A), 
     advisedby(C, A), 
     tempadvisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, 0.2059559107439094) :- 
     professor(B), 
     student(A), 
     !. // Clause #2.

advisedby(A, B, -0.10600575567921348) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   professor(b),
   student(a),
   advisedby(uniqueVar7, a),
   tempadvisedby(uniqueVar7, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, 0.2059559107439094) :-  /* #neg=10 #pos=78 */ 
   professor(b),
   student(a),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, -0.10600575567921348) :-  /* #neg=68 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   advisedby(uniqueVar7, a)
%   tempadvisedby(uniqueVar7, b)
%   professor(b)
%   student(a)

%%%%%  WILL-Produced Tree #8 @ 20:41:19 12/15/20.  [Using 3.736.832 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( professor(A), professor(B) )
%   then if ( tempadvisedby(C, A), tempadvisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return -0.12723413100102615;  // std dev = 0,000, 8,000 (wgt'ed) examples reached here.  /* #neg=8 */
%   else return 0.05946421337295473;  // std dev = 3,345, 148,000 (wgt'ed) examples reached here.  /* #neg=70 #pos=78 */


% Clauses:

advisedby(A, B, 0) :- 
     professor(A), 
     professor(B), 
     tempadvisedby(C, A), 
     tempadvisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, -0.12723413100102615) :- 
     professor(A), 
     professor(B), 
     !. // Clause #2.

advisedby(A, B, 0.05946421337295473) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   professor(a),
   professor(b),
   tempadvisedby(uniqueVar8, a),
   tempadvisedby(uniqueVar8, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, -0.12723413100102615) :-  /* #neg=8 */ 
   professor(a),
   professor(b),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, 0.05946421337295473) :-  /* #neg=70 #pos=78 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   tempadvisedby(uniqueVar8, b)
%   professor(b)
%   professor(a)
%   tempadvisedby(uniqueVar8, a)

%%%%%  WILL-Produced Tree #9 @ 20:41:19 12/15/20.  [Using 3.777.872 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( professor(B), student(A) )
%   then if ( advisedby(C, A), tempadvisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return 0.15118338696528708;  // std dev = 2,977, 88,000 (wgt'ed) examples reached here.  /* #neg=10 #pos=78 */
%   else return -0.09930303010077766;  // std dev = 0,048, 68,000 (wgt'ed) examples reached here.  /* #neg=68 */


% Clauses:

advisedby(A, B, 0) :- 
     professor(B), 
     student(A), 
     advisedby(C, A), 
     tempadvisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, 0.15118338696528708) :- 
     professor(B), 
     student(A), 
     !. // Clause #2.

advisedby(A, B, -0.09930303010077766) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   professor(b),
   student(a),
   advisedby(uniqueVar9, a),
   tempadvisedby(uniqueVar9, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, 0.15118338696528708) :-  /* #neg=10 #pos=78 */ 
   professor(b),
   student(a),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, -0.09930303010077766) :-  /* #neg=68 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   professor(b)
%   tempadvisedby(uniqueVar9, b)
%   student(a)
%   advisedby(uniqueVar9, a)

%%%%%  WILL-Produced Tree #10 @ 20:41:19 12/15/20.  [Using 3.817.032 memory cells.]  %%%%%

% FOR advisedby(A, B):
%   if ( professor(A), professor(B) )
%   then if ( sameperson(C, A), tempadvisedby(C, B) )
%   | then return 0;  // std dev = 0,000, 0,000 (wgt'ed) examples reached here.
%   | else return -0.10412810119108215;  // std dev = 0,000, 8,000 (wgt'ed) examples reached here.  /* #neg=8 */
%   else return 0.03694651870663026;  // std dev = 3,235, 148,000 (wgt'ed) examples reached here.  /* #neg=70 #pos=78 */


% Clauses:

advisedby(A, B, 0) :- 
     professor(A), 
     professor(B), 
     sameperson(C, A), 
     tempadvisedby(C, B), 
     !. // Clause #1.

advisedby(A, B, -0.10412810119108215) :- 
     professor(A), 
     professor(B), 
     !. // Clause #2.

advisedby(A, B, 0.03694651870663026) :- !. // Clause #3.


% The flattened versions of these clauses:

flattened_advisedby(a, b, 0) :- 
   professor(a),
   professor(b),
   sameperson(uniqueVar10, a),
   tempadvisedby(uniqueVar10, b),
   !. // Flattened version of clause #1.

flattened_advisedby(a, b, -0.10412810119108215) :-  /* #neg=8 */ 
   professor(a),
   professor(b),
   !. // Flattened version of clause #2.

flattened_advisedby(underscore, underscore, 0.03694651870663026) :-  /* #neg=70 #pos=78 */ 
   !. // Flattened version of clause #3.


% The unique flattened literals:
%   professor(b)
%   sameperson(uniqueVar10, a)
%   tempadvisedby(uniqueVar10, b)
%   professor(a)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%  Final call for computing score for advisedby.  %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

stepLength_tree1(1.0).
stepLength_tree2(1.0).
stepLength_tree3(1.0).
stepLength_tree4(1.0).
stepLength_tree5(1.0).
stepLength_tree6(1.0).
stepLength_tree7(1.0).
stepLength_tree8(1.0).
stepLength_tree9(1.0).
stepLength_tree10(1.0).

logPrior(-1.8).
advisedby(D, E, Total) :- // A general accessor. 
   advisedby(D, E, 1000000, Total), !.
advisedby(D, E, Total) :- waitHere("This should not fail", advisedby(D, E, Total)).

advisedby(D, E, TreesToUse, Total) :- // A tree-limited accessor (e.g., for tuning the number of trees to use).
   logPrior(LogPrior),
   getScore_advisedby_tree1(D, E, TreesToUse, Total1),
   getScore_advisedby_tree2(D, E, TreesToUse, Total2),
   getScore_advisedby_tree3(D, E, TreesToUse, Total3),
   getScore_advisedby_tree4(D, E, TreesToUse, Total4),
   getScore_advisedby_tree5(D, E, TreesToUse, Total5),
   getScore_advisedby_tree6(D, E, TreesToUse, Total6),
   getScore_advisedby_tree7(D, E, TreesToUse, Total7),
   getScore_advisedby_tree8(D, E, TreesToUse, Total8),
   getScore_advisedby_tree9(D, E, TreesToUse, Total9),
   getScore_advisedby_tree10(D, E, TreesToUse, Total10),
   Total is LogPrior + Total1 + Total2 + Total3 + Total4 + Total5 + Total6 + Total7 + Total8 + Total9 + Total10,
   !.
advisedby(D, E, TreesToUse, Total) :- waitHere("This should not fail", advisedby(D, E, TreesToUse, Total)).

getScore_advisedby_tree1(D, E, TreesToUse, 0.0) :- 1 > TreesToUse, !.
getScore_advisedby_tree1(D, E, TreesToUse, Total1) :- advisedby_tree1(D, E, Total), stepLength_tree1(StepLen), Total1 is Total * StepLen.

getScore_advisedby_tree2(D, E, TreesToUse, 0.0) :- 2 > TreesToUse, !.
getScore_advisedby_tree2(D, E, TreesToUse, Total2) :- advisedby_tree2(D, E, Total), stepLength_tree2(StepLen), Total2 is Total * StepLen.

getScore_advisedby_tree3(D, E, TreesToUse, 0.0) :- 3 > TreesToUse, !.
getScore_advisedby_tree3(D, E, TreesToUse, Total3) :- advisedby_tree3(D, E, Total), stepLength_tree3(StepLen), Total3 is Total * StepLen.

getScore_advisedby_tree4(D, E, TreesToUse, 0.0) :- 4 > TreesToUse, !.
getScore_advisedby_tree4(D, E, TreesToUse, Total4) :- advisedby_tree4(D, E, Total), stepLength_tree4(StepLen), Total4 is Total * StepLen.

getScore_advisedby_tree5(D, E, TreesToUse, 0.0) :- 5 > TreesToUse, !.
getScore_advisedby_tree5(D, E, TreesToUse, Total5) :- advisedby_tree5(D, E, Total), stepLength_tree5(StepLen), Total5 is Total * StepLen.

getScore_advisedby_tree6(D, E, TreesToUse, 0.0) :- 6 > TreesToUse, !.
getScore_advisedby_tree6(D, E, TreesToUse, Total6) :- advisedby_tree6(D, E, Total), stepLength_tree6(StepLen), Total6 is Total * StepLen.

getScore_advisedby_tree7(D, E, TreesToUse, 0.0) :- 7 > TreesToUse, !.
getScore_advisedby_tree7(D, E, TreesToUse, Total7) :- advisedby_tree7(D, E, Total), stepLength_tree7(StepLen), Total7 is Total * StepLen.

getScore_advisedby_tree8(D, E, TreesToUse, 0.0) :- 8 > TreesToUse, !.
getScore_advisedby_tree8(D, E, TreesToUse, Total8) :- advisedby_tree8(D, E, Total), stepLength_tree8(StepLen), Total8 is Total * StepLen.

getScore_advisedby_tree9(D, E, TreesToUse, 0.0) :- 9 > TreesToUse, !.
getScore_advisedby_tree9(D, E, TreesToUse, Total9) :- advisedby_tree9(D, E, Total), stepLength_tree9(StepLen), Total9 is Total * StepLen.

getScore_advisedby_tree10(D, E, TreesToUse, 0.0) :- 10 > TreesToUse, !.
getScore_advisedby_tree10(D, E, TreesToUse, Total10) :- advisedby_tree10(D, E, Total), stepLength_tree10(StepLen), Total10 is Total * StepLen.

flattenedLiteralsInThisSetOfTrees(advisedby, 24, [
   advisedby(uniqueVar7, a),
   tempadvisedby(uniqueVar1, b),
   tempadvisedby(uniqueVar8, a),
   tempadvisedby(uniqueVar9, b),
   tempadvisedby(uniqueVar1, a),
   advisedby(uniqueVar4, a),
   tempadvisedby(uniqueVar6, b),
   student(a),
   advisedby(uniqueVar9, a),
   tempadvisedby(uniqueVar10, b),
   student(b),
   tempadvisedby(uniqueVar7, b),
   sameperson(uniqueVar4, b),
   advisedby(uniqueVar2, a),
   advisedby(uniqueVar5, b),
   tempadvisedby(uniqueVar8, b),
   professor(b),
   sameperson(uniqueVar10, a),
   advisedby(uniqueVar3, b),
   tempadvisedby(uniqueVar5, a),
   sameperson(uniqueVar3, a),
   professor(a),
   tempadvisedby(uniqueVar2, b),
   advisedby(uniqueVar6, a)]).
